# 2020-07-21
# Informational links
- https://www.cplusplus.com/info/description/
    - Good overview of language types, nothing new for me =/
- https://www.cplusplus.com/info/history/
    - Skimmed, nice history on C++
- https://www.cplusplus.com/info/faq/
    - Good clarifications on a few things
    - Including that ANSI-C++ is a standard, whereas iirc there's inconsistencies between compilers so we have to wrangle with defined vs undefined behavior

# Tutorial
# https://www.cplusplus.com/doc/tutorial/introduction/

Assembly...

How compilation works...

Console programs...

Due to being on Linux, we'll use `g++`
Clang is good for OS X

# https://www.cplusplus.com/doc/tutorial/program_structure/
- Code comments
- `#` is a directive symbol
    - `#include` means to insert the code into this file (kind of like PHP `include`)
        - As opposed to Python and Node.js `import`/`require` which load that part of the program as a module which can be referenced but isn't in the same file per-se
    - `#include <iostream>` means include the *header* for iostream (still need to fully understand what a header is...)
- `int main ()` - Declare a function which returns an `int`, is called `main`, and takes 0 parameters
    - `main` is special as it's what's called when the program is run
    - Not mentioned: `int` is going to be the exit code of the program
        - If not specified, then the function will return `0` by default (success exit code)
- `std::cout` - `std` is standard, `cout` is character output
- `<<` is insertion operator so we insert the string to `std::cout`

- Multiple `std::cout` calls continues outputting

## Comments
- `//` is single line ocmment
- `/* */` is multiline comment

## Namespaces
- In some other code, might have seen no `std::` used
    - This is due to using the `std` namespace by default (see below)
    - However, `std::cout` and `cout` refer to the same object
        - `cout` is called unqualified
        - `std::out` is called qualified, with the namespace `std`
- `cout` is part of standard C++ library, declared within the `std` namespace
    - To refer to items within `std` namespace, program shally qualify usage of elements of library (e.g. `std::`) or "introduce visibility of its components"
        - Visibility is done most often with `using` delcaration
        - e.g. `using namespace std;`

Future code examples will use similar `using` syntax

Both are valid but only using non-`using` syntax is good to avoid name collisions (seems backwards reinforcement...)

For personal reference, here's the error when we try `cout` without `std::` and no `using namespace`:

```
main.cpp: In function ‘int main()’:
main.cpp:7:3: error: ‘cout’ was not declared in this scope
   cout << "Hello World!\n";
   ^~~~
main.cpp:7:3: note: suggested alternative:
In file included from main.cpp:2:0:
/usr/include/c++/7/iostream:61:18: note:   ‘std::cout’
   extern ostream cout;  /// Linked to standard output
```

Oooh, really cool insight that C++ std lib are just a file locally

```
less /usr/include/c++/7/iostream
```

# https://www.cplusplus.com/doc/tutorial/variables/
- Variables...

- Addition, subtraction, and equals operators (implicit)


## Identifiers
- Valid identifer is a sequence of at least 1 letter, digit, or underscore (no spaces, punctuation, or symbol allows)
    - Also always starts with a letter or underscore (usually only for compiler-specific keywords, external identifiers, or __ variants)

Here's an example error:

```
main.cpp: In function ‘int main()’:
main.cpp:9:7: error: expected unqualified-id before numeric constant
   int 1foo = 3;
       ^~~~
```

- Cannot use reserved keywords, giant list...
    ```
    alignas, alignof, and, and_eq, asm, auto, bitand, bitor, bool, break, case, catch, char, char16_t, char32_t, class, compl, const, constexpr, const_cast, continue, decltype, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, new, noexcept, not, not_eq, nullptr, operator, or, or_eq, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_assert, static_cast, struct, switch, template, this, thread_local, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while, xor, xor_eq
    ```
    - Some compilers might have more

- C++ is case-sensitive so RESULT !== result !== Result

## Fundamental data types
- Variable values are stored in memory at an unspecified location as 0s and 1s, don't need to know per-se
- We do need to know type though as interpretation and memory usage varies widely

- We've got the following types:

- Character types, representing text (e.g. 'A', '$')
    - `char`, a single character - One byte in size (at least 8 bits)
    - `char16_t`, "Not smaller than `char`" (at least 16 bits)
    - `char32_t`, "Not smaller than `char32_t`" (at least 32 bits)
    - `wchar_t` - *Can* reprepsent largest supported character set
        > It's annoying how these are all not rigid ("not smaller than", "can")
        > Really want it to be 16-bit character, 32-bit character, "is" not "can
        > Ugh...
- Numerical integer types (e.g. 7. 1024)
    > `signed`, not well explained but allows for +/- values down to half of range and up to half of range (e.g. 8 bits -> -128 to 127)
    > `unsigned`, full range from 0 to value (e.g. 8 bits -> 0 to 255)
    - `char`, at least 8 bits
    - `short`, at least 16 bits (at least `char`)
    - `int`, at least 16 bits (at least `short`)
    - `long int`, at least 32 bits (at least `int`)
    - `long long int`, at least 64 bits (at least `long`)
- Numerical floating-point types (e.g. 3.14, 0.01)
    > Broken down into significand/mantissa bits and exponent bits, kind of like 3.14e+14
    - `float`, no mention of bits
    - `double`, precision not less than `float`
    - `long double`, precision not less than `double`
- Boolean type (e.g. `true`, false`)
    - `bool`, 1 bit
- Void type
    - `void`, 0 bits (no storage)
- Null pointer
    - `decltype(nullptr)` (no info)
    > I'm guessing pointers are their own type which get size assigned by the OS?

Words `signed` and `int` can be omitted (except for in `char` case)
e.g. `signed short int` can be `signed short`, `short int`, or `short`

**None of the fundamental types have a standard size specified except `char`, only a minimum size at most**
This is due to different compilers and machines doing different things

"This allows for flexibility to work optimally in all kinds of platforms, both present and future"
> Hahaha... good joke there... so much broken code... so much -_-;;;

8-bit = 2^8 = 256 represnetable values
16-bit = 65,536
32-bit = 4,294,967,296 (~4 billion)
64-bit = 18,446,744,073,709,551,616 (~18 billion billion)

Clarification on signed vs unsigned: 655356 -> 0 to 65535 (unsigned), -32768 to 32767 (signed)
Yep, so I was right =D

Clarification on floating points, terms are called significant and exponent (mostly right before)

Limitations of a given system can be resolved via `numeric_limits` classes inside of `limits` header

> My eyes are glazing over when I see this... `template <class T>` keeps on throwing me/scaring me off =/
> https://www.cplusplus.com/reference/limits/numeric_limits/
> Ah, usage is like `std::numeric_limits<int>::min()`
> Staaarting to click a little

Paused at "If for some reason, types of specific sizes are needed, the library defines certain fixed-size type aliases in header <cstdint>."

# 2020-07-28
Aaaand we're back

https://www.cplusplus.com/reference/limits/numeric_limits/

```cpp
template <class T> class numeric_limits {
public:
  static T min() throw();
};

// Translates to usage:
//                   v static public method
numeric_limits<int>::min();
// ^ class,    ^ template class
```

https://www.cplusplus.com/doc/tutorial/variables/

Resuming tutorial now...

- Types (characters, integers, floating-point, and boolean) are known as arithmetic types
    - Huh, would have expected "primitive"
- `void` means it lacks a type
- `nullptr` is a special kind of pointer, not an arithmetic type
- Other types are known as compound data types

## Declaration of variables
- C++ strongly typed... requires declaration before use...
    - Useful for compiler...

```cpp
int a;
float mynumber;
```

- Scope of these declarations are allowed in the entirety of the rest of the program
- Can use commas for combined declaration (my experience in JS has taught me split line is better since usually declaration and initialization should go hand-in-hand)
    - `int a, b, c;`


- Code example: 02-variable-declaration

## Initialization of variables
- When variables declared but not set, their value is undetermined
    > What happens if we try to work with an undetermined value?
    > It seems to default to `0` usually but when we subtract, we're getting an underflow and varying between 32764 and 32767
    ```cpp
    // Process our variables
    // a = 5;
    // b = 2;
    // a += 1;
    result = a - b;
    ```
- Setting variable is called initalization
- 3 ways to initialize, whoa!
    - All valid and come from language evolution
    - C-like initialization
        - `type identifier = initial_value;`
        - e.g. `int x = 0;`
    - Constructor initialization (not part of C)
        - `type identifier (initial_value);`
        - e.g. `int x (0);`
    - Uniform initialization, similar to constructor variant, introduced in 2011:
        - `type identifier {initial_value};`
        - e.g. `int x {0};`
> These latter 2 seem strange, I bet they're more applicable to classes (I think C already had structs though so curious...)

- Code example: 03-variable-initialization

# Type deduction
- Compiler can automatically deduce type based on previous declarations
    - I've heard frustrating stories of libraries being inundated with `auto` and causing headaches =/
    ```cpp
    int foo = 0;
    auto bar = foo; // Uses `int bar`, based on `foo`
    ```
- If a variable only declared, not initialized, then they can use `decltype` for same effect:
    ```cpp
    int foo = 0;
    decltype(foo) bar;
    ```

- Warnings about intended for inability of not knowing type (e.g. library) or if it improves code readability, examples above decreased readability

## Introduction to strings
- Strings are a compound type, loaded via the `<string>` header
    ```cpp
    #include <string>
    // ...
    string mystring = "This is a string";
    ```
- Use same 3 initialization calls for demo purposes
- `endl` will print newline character (guessing this varies based on OS, e.g. Windows is `\r\n`, Linux is `\n` only)

- Lots of different constructor methods, https://www.cplusplus.com/reference/string/string/string/
    - Pretty sure we're just starting with the "from c-string" variant

- Code example 04-strings

- So many error messages when we forego `using namespace std;` o_o

```
main.cpp: In function ‘int main()’:
main.cpp:8:3: error: ‘string’ was not declared in this scope
   string mystring = "Hello World!";
   ^~~~~~
main.cpp:8:3: note: suggested alternatives:
In file included from /usr/include/c++/7/iosfwd:39:0,
                 from /usr/include/c++/7/ios:38,
                 from /usr/include/c++/7/ostream:38,
                 from /usr/include/c++/7/iostream:39,
                 from main.cpp:2:
/usr/include/c++/7/bits/stringfwd.h:74:33: note:   ‘std::__cxx11::string’
   typedef basic_string<char>    string;
                                 ^~~~~~
/usr/include/c++/7/bits/stringfwd.h:74:33: note:   ‘std::__cxx11::string’
main.cpp:11:16: error: ‘mystring’ was not declared in this scope
   std::cout << mystring << endl;
                ^~~~~~~~
main.cpp:11:16: note: suggested alternative: ‘stdin’
   std::cout << mystring << endl;
                ^~~~~~~~
                stdin
main.cpp:11:28: error: ‘endl’ was not declared in this scope
   std::cout << mystring << endl;
                            ^~~~
main.cpp:11:28: note: suggested alternative:
In file included from /usr/include/c++/7/iostream:39:0,
                 from main.cpp:2:
/usr/include/c++/7/ostream:590:5: note:   ‘std::endl’
     endl(basic_ostream<_CharT, _Traits>& __os)
     ^~~~
```

## Constants
## Literals
- Integer literals (e.g. 100, -200)
    - No quotes, representing base 10 by default
    - Octal, leading `0`: `0113`
    - Hexadecimal, leading `0x`: `0x4b`
    - Default is type `int`, for variation, use following:
        - u or U for unsigned: 75u
        - l or L for long: 75l
        - ll or LL for long long: 75ll
        - Demo: 75ul, unsigned long
- Floats, similar base 10 literals: (e.g. 3.14)
    - Supports exponent form (e.g. 6.02e23, 1.6e-19)
    - Modify with:
        - f or F for float: 6.02e23f
        - l or L for long double: 3.14159L
- String literals
    - Single character, use single quotes (e.g. 'z', 'p')
    - Strings (more than 1 char), use double quotes (e.g. "Hello world")
    - Special characters use `\` to escape (e.g. \n, \r, \', \\)
    - Can also use `\x` for hex version (e.g. `\x20`) and `\` with numbes for octal (e.g. `\24`)
    - Using spaces between string literals will concatenate them
        ```cpp
        "this" "is a"
        "single string"
        // Same as
        "thisis asingle string"
        ```
    - Using `\` in a string means line continuation which means line continues where it stopped
        ```cpp
        x = "string in \
        two lines"
        // Same as
        x = "string in two lines"
        ```
        - DONE: Does this work with indents?
            Indents count
        ```cpp
        int main() {
            x = "string in \
            two lines"
            // Same as
            x = "string in      two lines"
        }
        ```
    - By default, characters in string literal have type `char`. To modify, use:
        - u for char16_t
        - U for char32_t (note case sensitivity)
        - L for wchar_t
        - Attempted to use in example but getting conversion error =/
            ```
            main.cpp:8:26: error: conversion from ‘const char16_t [13]’ to non-scalar type ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’ requested
               std::string mystring = u"Hello World!";
            ```
    - Also have:
        - u8 for UTF-8 encoding (guess default is ASCII)
        - R is raw string (meaning all characters are taken as is, no escaping)
            - Usage: R"{sequence}contents{sequence}"
            ```cpp
            R"(string with \backslash)"
            R"&%$(string with \backslash)&%$"
            // Both equivalent to
            "string with a \\backslash"
- More literals:
    - Boolean: true/false
    - `nullptr` is null pointer value (unsure what that means, guessing 0?)
    ```cpp
    bool foo = true;
    bool bar = false;
    int* p = nullptr;
    ```

Head is feeling kind of full, stopping at "typed constant expressions" on https://www.cplusplus.com/doc/tutorial/constants/

Attempted to look ahead for header explainer, shocked to not see any
Reading this instead: https://www.cplusplus.com/articles/Gw6AC542/

- Multiple files speeds up compile time
    - I guess compiler caches results for each of the files?
- Multiple files is for organization, yep
- ... Alright, this file is going to get into the weeds and head is still full. Going to come back another time

... and back

- Multiple files allows for separating interface from implementation
    - So I guess overriding and such?

C++ built in 2 stages:
- Each file is compiled on its own into intermediate files, called object files (unrelated to objects in code)
- Then each file is linked together to final binary (program itself)

- Example code showing `.cpp` files aren't shared
    ```cpp
    // myclass.cpp
    class MyClass {
        // ...
    }
    ```
    ```cpp
    // main.cpp
    MyClass a; // Compile error: 'MyClass' is unidentified
    ```
- i.e. When we compile each `.cpp` file on its own, it doesn't have anything linking the files so they error out
    - Ohhh, gotcha

- Here's where header files come in (yay)
    - They define the interface (i.e. what MyClass receives and such) while leaving the implementation separate (in its own `.cpp` file)
    - I feel like it's not a great trade-off but alright
        - Could prob just as easily scrape the `.cpp` file for that info or something
        - Maybe it was a product of the times when processors and disk storage were a lot slower
- Updated example:
    ```cpp
    // myclass.h
    class MyClass
    {
    public:
        void foo();
    }

    // myclass.cpp
    #include "myclass.h"

    void MyClass::foo()
    {
        // Guessing this overrides `foo` placeholder
        // Curious how C++ distinguishes the files
    }

    // main.cpp
    #include "myclass.h"

    MyClass a; // No more error
    ```
- `#include` will copy/paste all of the `.h` into the file
    - I guess dead code will be abstracted away

## Distinction between .h/.cpp/.hpp/.cc/etc
- Fundamentally all text files but there's conventions

- Header files should use `.h/.hpp/.hxx`
- C++ source files should use `.cpp/.cxx/.cc`
- C source files should only use `.c`

We separate C++ from C as it affects some compilers
Since on a C++ site, prob only writing C++ so avoid the `.c` extension

Also, compilers might try to avoid header extensions

To reiterate from before:
- Header files are loaded via `#include` and not compiled
- Source files are not loaded via `#include` and are compiled

There are rare exceptions to the rule, your scenario prob doesn't count (only one listed is about templates which already sounds sketchy)
so yea... don't

## Include guards
- C++ compilers will complain if include is used twice
    ```cpp
    # include "myclass.h"
    # include "myclass.h" // Compiler error - MyClass already defined
    ```

- This can be frustrating if we include a file twice in multiple dependencies
    e.g. `a.h` imports `x.h`, `b.h` imports `x.h`, and `main.cpp` imports `a.h` and `b.h`
- Because of this, people are often told to avoid `#include` in header files which is bad advice
    - Sometimes instructed to do so, you can grudgingly do it but shake it once leaving the class
- Can do `#include` in header files but take precautions:
    - Only include what is needed
    - Guard against multiple includes:
        - Example:
        ```cpp
        // x.h
        #ifndef __X_H_INCLUDED__ // if x.h hasn't been included yet (if not defined)
        #define __X_H_INCLUDED__ //   #define this so the compiled knows it has been included

        class X { };
        #endif
        ```
        - Note: Because this logic is going in `x.h`, then it will always work -- nothing to put inside of `a.h` or `b.h`
        - I'm a little curious if we get global namespace pollution issues but I guess that comes later
        - Obviously no need to guard `.cpp` files like this since they aren't loaded via `#include`
        - DONE: I'm curious what built-ins do, do they do a similar setup?
            Oooh, they do =o
            > Via /usr/include/c++/7/string
            ```cpp
            #ifndef _GLIBCXX_STRING
            #define _GLIBCXX_STRING 1
            ```
            > Comical that `<string>` now mostly uses `<bits/*>` libraries

## Right way to include
Two kind of dependencies:
- Forward declared
- `#include`

Example: Class A uses Class B (thus A depends on B)

If A makes no reference to B, then do nothing
If A only refers to B in friend declaration, then do nothing

If A containers a B pointer or reference (e.g. B* myb), then use forward declaration
If one or more functions has a B obj/ptr/ref/etc, then use forward declaration

If B is a parent class of A, then use `#include`
If A contains a B object, then use `#include`

Full example:
```
// include guard
#ifndef __MYCLASS_H_INCLUDED__
#define __MYCLASS_H_INCLUDED__

// Forward declared dependencies
class Foo;
class Bar;

// included dependencies
#include <vector>
#include "parent.h"

// class itself
class MyClass : public Parent # Use as `Parent` so `#include "parent.h"`
{
public:
    std::vector<int> avector; // Uses vector as an object to `#include <vector>`
    Foo* foo; // Foo pointer, so forward declare Foo (I guess this is when we define the name of it only and allow others to fill in the rest?)
    void Func(Bar& bar); // Bar reference, so forward declare Bar

    friend class MyFriend; // friend declaration, not a dependency so nothing needed
}

#endif // __MYCLASS_H_INCLUDED__ (end of guard)
```

- Avoid unnecessary `#include` as it can lead to trouble

## Why was that the "right way"?
- Careless usage of `#include` can lead to trouble
    - One way to avoid it is abstinence but that leads to lots of work and headaches
- This methodology focuses on encapsulation and no other file needs to know internals of `.h` file
    - Alternative would mean loading all of `.h` dependencies in program, including its nested ones which is a paiiin

## Circular dependencies
> Usually this means misstructuring of code in my experience =/
> A parent with 2 children dependency or 2 parents with 1 child instead of 2 siblings with more code somewhere

But they say...
If we only need a forward declaration at some point, then circle is broken and it works

```cpp
// a.h
#include "b.h"

class A { B* b; };

// b.h
#include "a.h"

class B { A* a; };
// Still getting used to `;` on braces
```

This will result in infinite inclusion loop =/
but due to guarding, we stop recursing an error out

```cpp
#include "a.h"
    #include "b.h"
        #include "a.h"
            // Hit guard

    class B { A* a;} // Error: A is undeclared
```

"This is why always forward declare when using pointer or reference"
So we should be avoiding the circular `#include` altogether

If we use an object though (e.g. `B b;`, not `B* b;`), then need to do `#include`

... Impossible so just use a pointer or reference rather than full object
> Or y'know, break up the code...

## Function inlining
Function body needs to exist in every `.cpp` file which calls them, otherwise there are linker errors
> I'm a little curious how compiler knows which `.cpp` files to load and when but maybe that's just what's passed in or it sees the `.h` files

```cpp
class B
{
public:
    void Func(const A& a) // parameter so fwd declare is okay
    {
        a.DoSomething(); // a is dereferenced now so need an `include`, thus we have circular inclusion
    }
};
```

While inline function needs to exist in header, doesn't need to be in class definition, so can exploit via:

```
// b.h
class A; // fwd declared dependency

class B
{
public:
    void Func(const A& a); // Fwd declared A used, good
};

// Load a.h properly via `include`
#include "a.h"

inline void B::Func(const A& a)
{
    a.DoSomething(); // Works dude to `include
}
```

Wow, that's one clever hack. It breaks the circular dependency since it makes progress

- Function bodies at bottom header is ugly though, can we avoid it?
    - Yes, move bodies to another header (e.g. `b_inline.h`)
    - Hahaha, I guess that works

## Forward declaring templates
This is getting into a world which I'm very unfamiliar with and my eyes have glazed over

Going to call it as good enough for now and we can always come back

Calling it for the night here

# 2020-08-18
Resuming at "typed constant expressions" on https://www.cplusplus.com/doc/tutorial/constants/

- Using `const` before type declaration seems to make it a constant variable...
    ```cpp
    const double pi = 3.14159;
    const char tab = '\t';
    ```
- Curious what happens when we try to update it, they don't cover this but yea...
    - `05-const`, yep confirms expected
        ```
        main.cpp: In function ‘int main()’:
        main.cpp:14:8: error: assignment of read-only variable ‘pi’
           pi = 3.14;
                ^~~~
        ```

- Can also use `#define` via preprocessor which I believe does something different
    ```cpp
    # define PI 3.14159
    // ...
    cout << PI;
    ```
    - This behaves a replacement so overriding makes less sense
    - Unless... what happens when we override a `#DEFINE`?
        - Exploring in `06-define`
            - It outputs a warning
            ```
            main.cpp:6:0: warning: "PI" redefined
             #define PI 3

            main.cpp:5:0: note: this is the location of the previous definition
             #define PI 3.14159

            3
            ```
    - `#define` don't require semicolons since preprocessor directives
        - (and semicolon would be considered part of the line)

## Operators
https://www.cplusplus.com/doc/tutorial/operators/

- Assignment operator, `=`, assigns value to variable
    - e.g. `x = 5;`, `x = y;`
    - Operation takes place from right to left, this way we can retain value of `x` until it's ovewritten
    - Parentheses for prioritized evaluation (called an expression itself)
    - Can also assign multiple values in 1 shot
        - e.g. `x = y = z = 5;`
- Arithmetic operations, +, -, *, /, %
    - Same as in other C-based languages
- Compound assigmment
    - Arithmetic ones: +=, -=, *=, /=, %=
        - Same as other languages
    - Bitwise ones: >>=, <<=, &=, ^=, |=
        - Oddly bitwise not covered yet but same as other languages
- Increment and decrement: ++, --
    - Pre-fix and post-fix like other languages (`++x` vs `x++`)
    - Originally `++x`, `x+=1`, and `x=x+1` might have generated different code but nowadays same result
- Relational and comparison operators: `==`, `!=`, `>`, `<`, `>=`, `<=`
    - Same as other languages
    - Warning about `=` accidentally working
    - Seem to get errors when comparing mismatched types
        ```
        main.cpp: In function ‘int main()’:
        main.cpp:10:15: error: invalid operands of types ‘double’ and ‘const char [4]’ to binary ‘operator>’
           cout << (PI > "foo") << endl;
        ```
- Logical operators: !, &&, ||
    - Boolean logic like other languages
    - Short-circuits as expected
- Ternary operator: ?
    - `condition ? result1 : return2`
    - Same as others
- Comma operator: ,
    - Same as JS but I prefer to avoid it
    - Separates 2 or more expressions where only 1 is expected
        - e.g. `a = (b=3, b+2);`
        - Sets `b` to 3 and yields `b+2` so `a = 5` is result
- Bitwise operators: &, |, ^, ~, <<, >>
    - Same as other languages
    - Neat mention of Assembly equivalents: AND, OR, XOR, NOT, SHL, SHR respectively

- Explicit type casting operator
    - C way to convert: Parens on new type before expression (variable in this case)
        ```cpp
        int i;
        float f = 3.14;
        i = (int) f; // Truncated to 3
        ```
    - C++ way: Functional notation preceeding expression to be converted with expression in parens
        ```cpp
        i = int (f); // Curious why not `int(f)` (i.e. have space)
        ```
    - Both are valid
- sizeof
    - Accepts one parameter, either type or variable
    - Returns size in bytes of type/object
    - `x = sizeof (char);`, `x = 1` since `char` is 1 byte large
    - Determined at compile-time (thanks compiled languages)
- Other operators
    - They're skipping pointers and OOP operators for now
- Operator precedence, long annoying list
    - Make code obvious, don't rely on this list
    - Operators in this list not called out explicitly before
        - ::, scope qualifier
        - [], subscript
        - . ->, member access
        - & *, reference/deference
        - new delete, allocation/deallocation
        - .* ->*, access pointer
    - From personal knowledge:
        - We did cover `::` from namespace perspective, prob the same
        - `[]` is for arrays but those operator with data structure size and pointer arithmetic
        - Curious about `.` and `->`, those might be same as instance attributes in other languages but not sure
        - `&`, `*` (and usage on `.` and `->`) are pointer specific but still fuzzy on
        - `new` and `delete` are prob manual GC for class instances

## Basic Input/Output
https://www.cplusplus.com/doc/tutorial/basic_io/
- C++ uses abstraction called `streams` for input and output in sequential media (e.g. screen, keyboard, file)
- Stream is entity where program can insert or extract characters to/from
    - No need to know details about media or its internals

- Standard library provides following streams, some common sources and destinations
    - cin, standard input stream
    - cout, standard output stream
    - cerr, standard error (output) stream
    - clog, standard logging (output) stream
- Huh, I'e heard of all of these except for `clog`. What file descriptor is that?
    - 0 is input, 1 is output, 2 is error, is 3 logging in bash/Node.js?
    - https://www.programiz.com/cpp-programming/library-function/iostream/clog
    - `clog` outputs to `stderr` but it's buffered and doesn't automatically output
    - Verifying via `07-clog`
        - Yep, it goes to `stderr` and using `2>` redirect silences it
        ```
        $ ./07-clog/build-and-run.sh 2> /dev/null
        $ ./07-clog/build-and-run.sh 1> /dev/null
        Hello
        ```
        - Though they can be redirected in the program as well, https://stackoverflow.com/a/52365
        - Just defaults to `stderr`

- Standard output (cout)
    - By default this is the screen
- Output via `<<` (insertion operator)
    - Works with strings, numbers, and variables
    ```cpp
    cout << "Hello World";
    cout << 123;
    cout << foo;
    ```
- Can chain multiple `<<`
    - `cout << "Hello " << "World";`
    - as well as variable (e.g. `cout << "Hello " << name;`)

- Using `<< endl` will flush streams buffer, meaning it's written to the device
    - `cout` (generally) isn't buffered so this is fine
    - However `clog` is buffered so it will only log once flushed
- We can avoid flushing by providing `\n` instead of `endl`
    > Well that's annoying for cross-platform compatibility...

- Standard input (cin)
    - By default this is the keyboard
- Input via `>>` (extraction operator)
    ```cpp
    // Declare out variable
    int foo;

    // Then receive input onto it
    cin >> foo;
    ```
    - It does coercion from character to number for us, how nice =)
- Characters are only processed by `cin` once Enter/Return is pressed
- If user input doesn't align to the specified type, then the program continues without setting a value for `i` (which can yield undetermined results)
    - Most programs should check value was invalid/not, will cover later apparently
- Can chain multiple `>>`
    - `cin >> a >> b;`
    - equivalnet to `cin >> a; cin >> b;`

- `cin` and strings
- `cin` always considers whitespace (e.g. spaces, tabs, new line) as termination of value
- Use `getline` instead to get everything possible
    ```cpp
    #include <iostream>
    #include <string>
    string mystr;
    getline (cin, mystr);
    ```
    > I guess space after function name is how C++ style goes
    > That makes one of us...
- Termination is considered at Enter/Return press so it's recommended to always use `getline` over `cin`

- `stringstream`
- `sstream` header defined `stringstream` type which allows treating string as a stream
    - Thus allowing treatment like `cin`/`cout`
    - Most useful for converting strings to numbers and back
    - They've got an example using `getline()` to a string then coercing that to an integer
    - I guess we can't use `getline()` directly to an `int`
    ```cpp
    string mystr = "1204";
    int myint;
    stringstream(mystr) >> myint;
    ```
    - Further exploration in `08-stringstream`
    Yep, lots of complaints when using a number against `getline`
    but honestly, I'd expect using `cin` to make more sense then...
    but maybe it's for defense against super long lines?
    So strange...

Out of time at the moment
Pausing at the start of https://www.cplusplus.com/doc/tutorial/control/

...

And back, trying to sneak in another section tonight

## Statements and flow control
https://www.cplusplus.com/doc/tutorial/control/

- Statements broken up by `;`
- Curly braces define a block

- If/else if/else syntax, braces optional for 1 liner
    - Corresponds to statement (optional case) or block
    > Be a good person, always brace

- While loops...
    - Use `sleep_for` to count down
- Do-while loops...
- For loops...
    - Sections in parens can be left empty, use comma for chaining inside an expression
- All same format as JS (almost like JS is inspired by C...)

- Range-based for loop
    - `for ( declaration : range ) statement;`
    - Loops over elements in a range (i.e. sequence of elements; e.g. arrays, containers, types with `begin`/`end` functions)
    - Example: `for (char c : mystr) { /* c is character in mystr */ }`
    - Can use `auto` instead of explicit type if desired

- `break` and `continue` in loop

- Labels and `goto`
    - Label defined by `{name}:` (dedented in their syntax)
    - `goto` will jump to given label (e.g. `goto mylabel;`)
    - Ignores nesting levels an doesn't unwind stack (scary)

- `switch` with same pass-through/break syntax
    - No mention of type but I guess coercing to a string like in JS isn't an issue since the expression has a known type always
    - Limited by not being able to compare to non-constant expressions

## Functions
https://www.cplusplus.com/doc/tutorial/functions/

- Function syntax
    ```cpp
    type name ( param1, param2, ... ) { statements }
    ```
    - `type` - Return type
    - `name` - Function name
    - `paramX` - Parameter in format of `type parameterName`
    - `statements` - Function contents
    - Example:
    ```cpp
    int add (int a, int b) {
        return a+b;
    }
    ```
- `int main` is required and automatically called by compiler
- All other functions must be called from `main`

- Upon traversing into a function, primitive values are copied into the parameter variables
- No mention of pass-by-value vs pass-by-reference (I believe this might be a pointer thing, I guess we'll cover it later)

- Functions with no type (i.e. `void`)
- `void` allows skipping return
- It looks like `int main` can also skip `return` which implies `return 0;`
- Parentheses are required to invoke a function, otherwise it's treated as a declaration or statement
    - `printmsg();` vs `printmsg;`

- `return` value of `main`
    - If `return` is omitted, then compiler assumes `return 0;`
    - This only applies to `main` for historical reasons, all other functions need to `return`
        > Prob also for the best, makes code more obvious
- Main returns exit code (though not saying that outright)
- `0` means success, `EXIT_SUCCESS` (from `cstdlib`) is same
- `EXIT_FAILURE` is in `cstdlib`
    - On my machine, this is just 1 (used as `return EXIT_FAILURE;`)

- Arguments passed by value and by reference
    - By default, passing by value which means modifications inside function are isolated to function
    ```cpp
    void increase (int a) {
        a *= 2;
    }
    ```
    - Any calls to `increase` doesn't adjust `a`
- If we use `&` to reference the same variable, then it can be mutated directly
    ```cpp
    void increase (int& a) {
        a *= 2;
    }
    ```
    - Any calls do modify `a` outside of its scope
    - That's pretty damn powerful o_o
    - In JS, we only get that on arrays and objects. Same with Python (lists/dicts)
    - Going to play with this for amazement
    - And curious how passing a string goes by value...
    - And curious if people prefer to avoid this due to mutating inputs usually being frowned upon, but maybe good for memory saving when just want to read

- Efficiency considerations and `const` references
- Calling with fundamentals (e.g. `int`) is relatively inexpensive
- It can get costly for compound types (e.g. `string`)
    - e.g. `string concatenate (string a, string b) { return a+b; }`
    - Pass-by-reference has same result, no mutation, and more efficient memory-wise
- To avoid contaminating input pass-by-references, use `const` on the qualifying parameters
    - e.g. `string concatenate (const string& a, const string& b)`
- Note: For fundamental types, using `&` and `const` may actually be less efficient (usually just equal though)

My eyes are glazing over so going to call it here
"inline functions" in https://www.cplusplus.com/doc/tutorial/functions/ is where I'll stop for tonight

# 2020-08-19
- Inline functions, uses `inline` keyword before type
    - e.g. `inline string add (int a, int b)`
- Recommends compiler inlines the function logic rather than use call stack and jumping
- Note: Compilers might already inline functions, even without this recommendation, for efficiency. This is more of a recommendation/preference to the compiler

- Default values in parameters
- Use `={value}` after parameter name for a default value
    - e.g. `int divide(int a, int b=2)`
- Allows `b` to be optional in invocation (e.g. `divide(12)` not `divide(12, 2)`)
- I'm curious how this handles strings and `&`
    - In JS and Python, default parameters are mutable to lists/arrays can be mutated across calls which is an anti-pattern
    - Exploring in `10-default-values`
    - TIL We can't use `&` with string literals
        - `string output = concat("foo", "bar");`
    - We get a complaint for `&` with default values similarly
        ```cpp
        string concat(string& a, string& b="hi") {
        ```
        ```
        main.cpp:5:40: error: cannot bind non-const lvalue reference of type ‘std::__cxx11::string& {aka std::__cxx11::basic_string<char>&}’ to an rvalue of type ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’
         string concat(string& a, string& b="hi") {
                                                ^
        In file included from /usr/include/c++/7/string:52:0,
        ...
        ```
    - If we use no `&`, then it works fine
    - We can also do overloading of functions and it works great too =D

- Functions cannot called before they are declared
    - This is why `main` is always written last
    - Huh, interesting... I guess it's true that I'd expect the overload functionality we wrote to work in either order
- Prototype of a funciton can be declared without defining it (only stating types, no names required)
    ```cpp
    // Prototype declaration
    void echo (int x);

    // Definitions and invocations
    int main () {
        odd(1);
    }
    void echo (int x) {
        cout << x;
    }
    ```
- It's not that efficient but it works

- Recursivity... yep
- Mention of stack overflow but I wonder if there's a stack limit like in JS and Python (1500 iirc)
    - It stops after OS-specific stack limit (e.g. 8MB), https://stackoverflow.com/a/2630091
    - Explored in `11-infinite-recursion`
    ```
    1
    ...
    261795
    ./11-infinite-recursion/build-and-run.sh: line 13: 10988 Segmentation fault      (core dumped) ./main.out
    ```
    - Result is similar for `&` reference variant

## Overloads and templates
https://www.cplusplus.com/doc/tutorial/functions2/

- Overloading allows for using same name for different functions with different types
    ```cpp
    int operate (int a, int b) { ... }
    double operate (double a, double b) { ... }
    ```
- Haven't used it in so long, not since Java days o_o
- In JS and Python, we just do type checking in the function itself
- Note: Functions cannot be overloaded on by return type, must have parameter change

- Function templates, generalizes overloading
    - Similar syntax to function declarations
    - Use `template <template-parameters> function-declaration`
    - Template parameters are separated by commas, can be either `class` or `typename` keyword then identifier
        - e.g. `class SomeType`
    - Generic usage:
    ```cpp
    template <class SomeType>
    SomeType sum (SomeType a, SomeType b) {
        return a+b;
    }
    ```
    - DONE: Alright, so how do we say to only do that for ints and doubles but not strings?
        - It's opt-in so far
    - And prob could have used a better name like `class Numeric` or `class Number`
    - DONE: And how do we end a `template` declaration? Is it only for that one function?
        - It's only for the specific function so far
- `class` and `typename` can be exchanged freely, compilers don't care (e.g. `class SomeType` equivalent to `typename SomeType`)
- `SomeType` is being reference as "generic type" and it can be used anywhere in the function
- Type usage is done at invocation time (huh, interesting...)
    - Syntax: `function-name <template-arguments> (function-arguments)`
    - `x = sum<int>(10, 20);`
    - Equivalent to using an `int sum (int a, int b)` (in case that wasn't clear
- In another example, they use `<class T>` which I guess could be clear but also feels slightly confusing
    - They say it's common so I guess it's like `i` and loops
- Compiler can guess type based on parameters so we can also skip `<int>` at invocation
    ```cpp
    int i=5, j=6;
    double f=2.0, g=0.5;
    k = sum(i, j);
    h = sum(f, g);
    ```
    - Sometimes the ambiguity is confusing for the compiler though so I guess use at your discretion
- More examples with `class T, class U` and it comparing `int, double` implicitly

- Non-type template arguments
- Templates can also take fundamental types instead of `class`/`typename`
    ```cpp
    template <class T, int N>
    T fixed_multiply (T val) {
        return val * N;
    }

    fixed_multiply<int, 2>(10);
    ```
- Strange but interesting
- Feels like an anti-pattern though...
- Distinction is: Value of template parameters is determined at compile time and generates 2 different functions
    - Technically no parameter passing/call stack for the "2". It's just always there
    - I guess this is a trade-off between memory usage and computational complexity, though obviously situation is contrived
    - Also legibility...

## Name visibility
https://www.cplusplus.com/doc/tutorial/namespaces/

- Scopes, use block scoping
- Entity at top level has global scope
- Variables within blocks are local variabbles
- Cannot double declare name for multiple entities (e.g. `int x; double x;`)

- Inner blocks can override outer block scopes (e.g. `int x; { int x; }`)
    - Though imo, I'd avoid this for confusion
- Variables as function parameters or in expressions for blocks (e.g. `for` loops) are local to the scope they're introducing


- Namespaces, allow grouping entities that would have global scope into a namespace scope
    - Syntax:
    ```cpp
    namespace identifier {
        named_entities
    }
    ```
    - Example:
    ```cpp
    namespace myNamespace {
        int a;
        int val() { return 5; }
    }
    // Used as
    myNamespace::a;
    myNamespace::val;
    ```
- Multiple namespaces can exist in same file in program
- Not required to specify current namespace within a namespace
    ```cpp
    namespace foo {
        const double pi = 3.14;
        double tau() { return 2 * pi; }
    }
    ```
- Can split up namespace definitions
    ```cpp
    namespace foo { int a; }
    namespace bar { int b; }
    namespace foo { int c; }
    ```
    - This also applies to multiple files


- `using`, declares usage of namespace in a current declarative region (e.g. block)
    ```cpp
    # include <iostream>
    using namespace std;

    namesapce first { int x = 5; }
    namesapce second { int y = 6; }

    int main () {
        using first::x;
        using second::y;
        cout << x << y;
    }
    ```
- As per example: Can use multiple and also call out specific items being declared via `using` with `::` syntax (I like that a lot)
    - I feel like there could be a whole convention `using std::cout; // iostream` but that might be overly verbose
        - Still a bummer that C++ doesn't do import like other languages =/
    - The `using first` and `using second` don't call out the explicit namespace either
    - Still feel like I'd like to avoid these if possible, but I'm sure I'll find the middle ground of useful and confusing
- Can use multiple `using namespace` calls
    ```cpp
        # include <iostream>
    using namespace std;

    namesapce first { int x = 5; }
    namesapce second { int x = 6; }

    int main () {
        using namesapce first;
        cout << x << second::x;
    }
    ```
- Can use in any `{}` block, not just in a function due to block scoping
- Namespaces can be aliased via: `namespace new_name = current_name;`

- All standard C++ library entites are contained by `std` namespace
    - e.g. Can use `std::cout` instead of `using namespace std; cout`
- Mostly stylistic for namespace but projects mixing libraries tend to prefer explicit qualification

- Storage classes
- Storing variable for entire duration of program (global or namespace scope), known as static storage
- Variables with static storage without explicit initialization value are set to zero
- Variables with automatic storage (block scoped) get undetermined value
    ```cpp
    int x; // 0
    int main () {
        int y; // Undetermined (e.g 428....)
    }
    ```

# 2020-09-01
# Arrays
https://www.cplusplus.com/doc/tutorial/arrays/

- Array is series of elements (same type) stored in continguous memory location
- Can reference each element by using adding an index to an identifier
- e.g. `int foo [5];` is an array of 5 integers
    - Indicies are base-0 so 0, 1, 2, 3, 4
- Syntax: `type name [elements];`
    - `type` is `int`, `float`, etc
    - `elements` is length of the array. This must be a constant expression
        - Arrays get their memory at compile time, they're not dynamic in size (at least not built-in version

## Initializing arrays
- By default, local scope arrays are uninitialized (i.e. values of items are undetermined (soo like other declarations))
- Use following syntax for specifying initialization values
    - `int foo [5] = { 16, 2, 77, 40, 12071 };`
- Can set first `n` values and let defaults become type's default (e.g. zeroes)
    - `int bar [5] = { 10, 20, 30 };` -- equivalent to `{ 10, 20, 30, 0, 0 };`
- This also works with no values `{ }; ` would be `{ 0, 0, 0, 0, 0 };`

- C++ allows for assuming element count based on initializer itself
- To do this, skip specifying the `elements` count in the `[]`
- `int foo [] = { 16, 2, 77 };` (automatically chooses 3 elements)

- `=` sign is optional for this as well due to supporting "universal initialization"
- `int foo [] { 16, 2, 77 };`

- Static arrays and those declared in a namespace are always initialized

## Accessing the values of an array
- Get/set as expected:
- `foo [2] = 75;`
- `x = foo[2];`
- Remember: Index 2 is third element

- C++ does allow exceeding valid range of indicies for an array (ugh)
- Doesn't lead to compilation errors but can lead to runtime issues

- Calling out distinction between `int foo[5]` to declare and `foo[2] = 75;` to set

## Multi-dimensional arrays
- Array of arrays
- 2-dimensional table that's 3x5 is `int jimmy [3][5];`
    - Accessing second row, fourth column is `jimmy[1][3]`
- Can do as many dimensions as we want: `char century [100][365][24][60][60];`
    - Note: This is very large (3 billion char), exponential increase for each new dimension

- In memory, these are equivalent to 1-dimensional arrays (e.g. `[3][5]` is same as `[15]`)
    > Makes sense, 1 large chunk, same space
    > Kind of nice since higher level languages actually do work around arrays/lists, though that's likely due to dynamic sizing potential
- Think of this as syntactic sugar, really useful kind though

## Arrays as parameters
- Cannot pass entire block of memory as a function argument
- Instead, can pass address (soo pointer?)
- In practice, almost same effect and much faster/more efficient

- To accept array as parameter, can state type is an array but omit the size:
    - `void procedure (int arg[])`
- Call function with desired array
    ```cpp
    int myarray [40];
    procedure (myarray);
    ```
- Full example given, kind of want to play with it directly
    - Folder: `12-array-passing`
    - Oddly they want length to be passed as its own parameter
        - If we try to use `sizeof`, this is supposed to be used for pointers?
        ```
        main.cpp: In function ‘void printarr(int*)’:
        main.cpp:7:33: warning: ‘sizeof’ on array function parameter ‘arr’ will return size of ‘int*’ [-Wsizeof-array-argument]
           for (int i = 0; i < sizeof(arr); i += 1) {
                                         ^
        main.cpp:6:23: note: declared here
         void printarr(int arr[]) {
                               ^
        5 10 15 -2089625856 247606496 -1546749280 22001 -1525691497
        ```
        - There's something right about `sizeof` but it's off... =/ https://www.educative.io/edpresso/how-to-find-the-length-of-an-array-in-cpp
            - Also pointer artihmetic
        - The `array<>` type has a `.size()` method which is prob more practical, https://www.cplusplus.com/reference/array/array/size/
    - Curious also about when we don't specify type of `[]`
        - It errors out
        ```
        main.cpp: In function ‘int main()’:
        main.cpp:18:39: error: invalid conversion from ‘int*’ to ‘int’ [-fpermissive]
           printarr(multiples, multiples_length);
                                               ^
        main.cpp:7:6: note:   initializing argument 1 of ‘void printarr(int, int)’
         void printarr(int arr, int length) {
              ^~~~~~~~
        ```
    - Also kind of curious why they said content at the start about not passing entire block, it sure feels like it
        - Based on the errors we're seeing, it seems they're passing a pointer via syntactic sugar more than anything else
        - and the pointer is just an `int`/similar which is fine
    - But also why no `&` to pass-by-reference syntax... Are we just passing the pointer?
        - Yep, we see `int*` in our output

- Can also take multidimensional arrays as input
    `void procedure (int myarray[][3][4])` (wants depth for additional dimensions)
    - Just checked that we can use this same syntax with the input length as well, but C++ doesn't care about right count
    - It does care about nested counts though, though maybe not about the exact count either, just n-dimensions
    ```
    main.cpp: In function ‘int main()’:
    main.cpp:17:39: error: cannot convert ‘int*’ to ‘int (*)[3]’ for argument ‘1’ to ‘void printarr(int (*)[3], int)’
       printarr(multiples, multiples_length);
    ```
- Passing an array as an argument always loses a dimension
    - This is for historical arrays of arrays not being directly copied, thus it's really a pointer being passed (will cover later)

## Library arrays
- Arrays are inherited from C but their resitrctions can lead to suffering from excess of optimization
- C++ offers an alternative array type as a standard container, via `<array>` header (oh hey, this is what I called out)
    - It's a type template (class template)

- Containers are library feature outside of tutorial scope but they exist similar to built-in arrays, except allow being copied (can be expensive) and only switch to pointers when told to (by virtue of `data` member)

- Example usage:
    ```cpp
    #include <array>
    // ...
    array<int,3> myarray {10,20,30};
    for (int i=0; i < myarray.size(); ++i) {
        ++myarray[i];
    }
    ```
    > Nice, sane `.size()` usage =)

- Looked at `/usr/incude/c++/7/array`
    - It doesn't have anything classical about it, looks just like a template so everything is done at compile time
    - Really slick with no overhead I see ._.
    - Actually, nvm. There's a lot more variables in the data structure...
    - Containers are just a name given to classes/types that store (e.g. array, queue), https://www.cplusplus.com/reference/stl/

# 2020-09-02
# Strings
https://www.cplusplus.com/doc/tutorial/ntcs/

- String class/literal can instead be represented by sequence of characters (char array)
    - e.g. `char foo [20];`
    - Can store both "Hello" and full 20 character string here
    - By convnetion, `null` character (`\0`) represents the end of a string
    - `char foo [20] = { 'H', 'e', 'l', 'l', 'o', '\0' };
    > So really we have space for 19 characters, no 20?

## Initialization of null-terminated character sequence
- `char foo [] = { 'H', 'e', 'l', 'l', 'o', '\0' };
- Uses up 6 elements: 5 characters stated + `null` character at end

- Can also use string literal to define char array
- Double quotes are the literal constants for this and auto-append `\0` at end of array
- These are equivalent
- `char foo [] = { 'H', 'e', 'l', 'l', 'o', '\0' };
- `char foo [] = "Hello";`

- Due to initialization setup/being an array, cannot overwrite later on
- The following are all invalid:
    ```cpp
    foo = "Bye";
    foo[] = "Bye";
    foo = {'B', 'y', 'e', '\0'};
    ```
- Instead, need to set values individually (well that's tedious but makes sense, same in any other language from an array perspective)
    ```cpp
    myword[0] = 'B';
    myword[1] = 'y';
    myword[2] = 'e';
    myword[3] = '\0';
    ```
    > We can however overwrite with `string` types easily which is nice

## Strings and null-terminated character sequences
- Plain arrays with null-terminated tails are typically used in C (known as C-strings)
- Even in C++, where there's the `string` type, C-Strings are quite normal
- String literals always produce null-terminated character sequences, not `string` objects

- Both C-string and library strings coexist, most functions support both via overloading
    - e.g. `cin >> char[]` and `cin >> string` work for both as does `cout`

- One notable difference is C-strings have a fixed size whereas library strings are dynamically sized during runtime

- Can also jump between types easily:
    ```cpp
    char my_c_str[] = "some text";
    string my_string = my_c_str;

    char my_c_str2[] = my_string.c_str();
    // Betting this is just dynamically sized array so can no optimization here even =/
    ```
