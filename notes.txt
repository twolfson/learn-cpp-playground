# 2020-07-21
# Informational links
- https://www.cplusplus.com/info/description/
    - Good overview of language types, nothing new for me =/
- https://www.cplusplus.com/info/history/
    - Skimmed, nice history on C++
- https://www.cplusplus.com/info/faq/
    - Good clarifications on a few things
    - Including that ANSI-C++ is a standard, whereas iirc there's inconsistencies between compilers so we have to wrangle with defined vs undefined behavior

# Tutorial
# https://www.cplusplus.com/doc/tutorial/introduction/

Assembly...

How compilation works...

Console programs...

Due to being on Linux, we'll use `g++`
Clang is good for OS X

# https://www.cplusplus.com/doc/tutorial/program_structure/
- Code comments
- `#` is a directive symbol
    - `#include` means to insert the code into this file (kind of like PHP `include`)
        - As opposed to Python and Node.js `import`/`require` which load that part of the program as a module which can be referenced but isn't in the same file per-se
    - `#include <iostream>` means include the *header* for iostream (still need to fully understand what a header is...)
- `int main ()` - Declare a function which returns an `int`, is called `main`, and takes 0 parameters
    - `main` is special as it's what's called when the program is run
    - Not mentioned: `int` is going to be the exit code of the program
        - If not specified, then the function will return `0` by default (success exit code)
- `std::cout` - `std` is standard, `cout` is character output
- `<<` is insertion operator so we insert the string to `std::cout`

- Multiple `std::cout` calls continues outputting

## Comments
- `//` is single line ocmment
- `/* */` is multiline comment

## Namespaces
- In some other code, might have seen no `std::` used
    - This is due to using the `std` namespace by default (see below)
    - However, `std::cout` and `cout` refer to the same object
        - `cout` is called unqualified
        - `std::out` is called qualified, with the namespace `std`
- `cout` is part of standard C++ library, declared within the `std` namespace
    - To refer to items within `std` namespace, program shally qualify usage of elements of library (e.g. `std::`) or "introduce visibility of its components"
        - Visibility is done most often with `using` delcaration
        - e.g. `using namespace std;`

Future code examples will use similar `using` syntax

Both are valid but only using non-`using` syntax is good to avoid name collisions (seems backwards reinforcement...)

For personal reference, here's the error when we try `cout` without `std::` and no `using namespace`:

```
main.cpp: In function ‘int main()’:
main.cpp:7:3: error: ‘cout’ was not declared in this scope
   cout << "Hello World!\n";
   ^~~~
main.cpp:7:3: note: suggested alternative:
In file included from main.cpp:2:0:
/usr/include/c++/7/iostream:61:18: note:   ‘std::cout’
   extern ostream cout;  /// Linked to standard output
```

Oooh, really cool insight that C++ std lib are just a file locally

```
less /usr/include/c++/7/iostream
```

# https://www.cplusplus.com/doc/tutorial/variables/
- Variables...

- Addition, subtraction, and equals operators (implicit)


## Identifiers
- Valid identifer is a sequence of at least 1 letter, digit, or underscore (no spaces, punctuation, or symbol allows)
    - Also always starts with a letter or underscore (usually only for compiler-specific keywords, external identifiers, or __ variants)

Here's an example error:

```
main.cpp: In function ‘int main()’:
main.cpp:9:7: error: expected unqualified-id before numeric constant
   int 1foo = 3;
       ^~~~
```

- Cannot use reserved keywords, giant list...
    ```
    alignas, alignof, and, and_eq, asm, auto, bitand, bitor, bool, break, case, catch, char, char16_t, char32_t, class, compl, const, constexpr, const_cast, continue, decltype, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, new, noexcept, not, not_eq, nullptr, operator, or, or_eq, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_assert, static_cast, struct, switch, template, this, thread_local, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while, xor, xor_eq
    ```
    - Some compilers might have more

- C++ is case-sensitive so RESULT !== result !== Result

## Fundamental data types
- Variable values are stored in memory at an unspecified location as 0s and 1s, don't need to know per-se
- We do need to know type though as interpretation and memory usage varies widely

- We've got the following types:

- Character types, representing text (e.g. 'A', '$')
    - `char`, a single character - One byte in size (at least 8 bits)
    - `char16_t`, "Not smaller than `char`" (at least 16 bits)
    - `char32_t`, "Not smaller than `char32_t`" (at least 32 bits)
    - `wchar_t` - *Can* reprepsent largest supported character set
        > It's annoying how these are all not rigid ("not smaller than", "can")
        > Really want it to be 16-bit character, 32-bit character, "is" not "can
        > Ugh...
- Numerical integer types (e.g. 7. 1024)
    > `signed`, not well explained but allows for +/- values down to half of range and up to half of range (e.g. 8 bits -> -128 to 127)
    > `unsigned`, full range from 0 to value (e.g. 8 bits -> 0 to 255)
    - `char`, at least 8 bits
    - `short`, at least 16 bits (at least `char`)
    - `int`, at least 16 bits (at least `short`)
    - `long int`, at least 32 bits (at least `int`)
    - `long long int`, at least 64 bits (at least `long`)
- Numerical floating-point types (e.g. 3.14, 0.01)
    > Broken down into significand/mantissa bits and exponent bits, kind of like 3.14e+14
    - `float`, no mention of bits
    - `double`, precision not less than `float`
    - `long double`, precision not less than `double`
- Boolean type (e.g. `true`, false`)
    - `bool`, 1 bit
- Void type
    - `void`, 0 bits (no storage)
- Null pointer
    - `decltype(nullptr)` (no info)
    > I'm guessing pointers are their own type which get size assigned by the OS?

Words `signed` and `int` can be omitted (except for in `char` case)
e.g. `signed short int` can be `signed short`, `short int`, or `short`

**None of the fundamental types have a standard size specified except `char`, only a minimum size at most**
This is due to different compilers and machines doing different things

"This allows for flexibility to work optimally in all kinds of platforms, both present and future"
> Hahaha... good joke there... so much broken code... so much -_-;;;

8-bit = 2^8 = 256 represnetable values
16-bit = 65,536
32-bit = 4,294,967,296 (~4 billion)
64-bit = 18,446,744,073,709,551,616 (~18 billion billion)

Clarification on signed vs unsigned: 655356 -> 0 to 65535 (unsigned), -32768 to 32767 (signed)
Yep, so I was right =D

Clarification on floating points, terms are called significant and exponent (mostly right before)

Limitations of a given system can be resolved via `numeric_limits` classes inside of `limits` header

> My eyes are glazing over when I see this... `template <class T>` keeps on throwing me/scaring me off =/
> https://www.cplusplus.com/reference/limits/numeric_limits/
> Ah, usage is like `std::numeric_limits<int>::min()`
> Staaarting to click a little

Paused at "If for some reason, types of specific sizes are needed, the library defines certain fixed-size type aliases in header <cstdint>."

# 2020-07-28
Aaaand we're back

https://www.cplusplus.com/reference/limits/numeric_limits/

```cpp
template <class T> class numeric_limits {
public:
  static T min() throw();
};

// Translates to usage:
//                   v static public method
numeric_limits<int>::min();
// ^ class,    ^ template class
```

https://www.cplusplus.com/doc/tutorial/variables/

Resuming tutorial now...

- Types (characters, integers, floating-point, and boolean) are known as arithmetic types
    - Huh, would have expected "primitive"
- `void` means it lacks a type
- `nullptr` is a special kind of pointer, not an arithmetic type
- Other types are known as compound data types

## Declaration of variables
- C++ strongly typed... requires declaration before use...
    - Useful for compiler...

```cpp
int a;
float mynumber;
```

- Scope of these declarations are allowed in the entirety of the rest of the program
- Can use commas for combined declaration (my experience in JS has taught me split line is better since usually declaration and initialization should go hand-in-hand)
    - `int a, b, c;`


- Code example: 02-variable-declaration

## Initialization of variables
- When variables declared but not set, their value is undetermined
    > What happens if we try to work with an undetermined value?
    > It seems to default to `0` usually but when we subtract, we're getting an underflow and varying between 32764 and 32767
    ```cpp
    // Process our variables
    // a = 5;
    // b = 2;
    // a += 1;
    result = a - b;
    ```
- Setting variable is called initalization
- 3 ways to initialize, whoa!
    - All valid and come from language evolution
    - C-like initialization
        - `type identifier = initial_value;`
        - e.g. `int x = 0;`
    - Constructor initialization (not part of C)
        - `type identifier (initial_value);`
        - e.g. `int x (0);`
    - Uniform initialization, similar to constructor variant, introduced in 2011:
        - `type identifier {initial_value};`
        - e.g. `int x {0};`
> These latter 2 seem strange, I bet they're more applicable to classes (I think C already had structs though so curious...)

- Code example: 03-variable-initialization

# Type deduction
- Compiler can automatically deduce type based on previous declarations
    - I've heard frustrating stories of libraries being inundated with `auto` and causing headaches =/
    ```cpp
    int foo = 0;
    auto bar = foo; // Uses `int bar`, based on `foo`
    ```
- If a variable only declared, not initialized, then they can use `decltype` for same effect:
    ```cpp
    int foo = 0;
    decltype(foo) bar;
    ```

- Warnings about intended for inability of not knowing type (e.g. library) or if it improves code readability, examples above decreased readability

## Introduction to strings
- Strings are a compound type, loaded via the `<string>` header
    ```cpp
    #include <string>
    // ...
    string mystring = "This is a string";
    ```
- Use same 3 initialization calls for demo purposes
- `endl` will print newline character (guessing this varies based on OS, e.g. Windows is `\r\n`, Linux is `\n` only)

- Lots of different constructor methods, https://www.cplusplus.com/reference/string/string/string/
    - Pretty sure we're just starting with the "from c-string" variant

- Code example 04-strings

- So many error messages when we forego `using namespace std;` o_o

```
main.cpp: In function ‘int main()’:
main.cpp:8:3: error: ‘string’ was not declared in this scope
   string mystring = "Hello World!";
   ^~~~~~
main.cpp:8:3: note: suggested alternatives:
In file included from /usr/include/c++/7/iosfwd:39:0,
                 from /usr/include/c++/7/ios:38,
                 from /usr/include/c++/7/ostream:38,
                 from /usr/include/c++/7/iostream:39,
                 from main.cpp:2:
/usr/include/c++/7/bits/stringfwd.h:74:33: note:   ‘std::__cxx11::string’
   typedef basic_string<char>    string;
                                 ^~~~~~
/usr/include/c++/7/bits/stringfwd.h:74:33: note:   ‘std::__cxx11::string’
main.cpp:11:16: error: ‘mystring’ was not declared in this scope
   std::cout << mystring << endl;
                ^~~~~~~~
main.cpp:11:16: note: suggested alternative: ‘stdin’
   std::cout << mystring << endl;
                ^~~~~~~~
                stdin
main.cpp:11:28: error: ‘endl’ was not declared in this scope
   std::cout << mystring << endl;
                            ^~~~
main.cpp:11:28: note: suggested alternative:
In file included from /usr/include/c++/7/iostream:39:0,
                 from main.cpp:2:
/usr/include/c++/7/ostream:590:5: note:   ‘std::endl’
     endl(basic_ostream<_CharT, _Traits>& __os)
     ^~~~
```

## Constants
## Literals
- Integer literals (e.g. 100, -200)
    - No quotes, representing base 10 by default
    - Octal, leading `0`: `0113`
    - Hexadecimal, leading `0x`: `0x4b`
    - Default is type `int`, for variation, use following:
        - u or U for unsigned: 75u
        - l or L for long: 75l
        - ll or LL for long long: 75ll
        - Demo: 75ul, unsigned long
- Floats, similar base 10 literals: (e.g. 3.14)
    - Supports exponent form (e.g. 6.02e23, 1.6e-19)
    - Modify with:
        - f or F for float: 6.02e23f
        - l or L for long double: 3.14159L
- String literals
    - Single character, use single quotes (e.g. 'z', 'p')
    - Strings (more than 1 char), use double quotes (e.g. "Hello world")
    - Special characters use `\` to escape (e.g. \n, \r, \', \\)
    - Can also use `\x` for hex version (e.g. `\x20`) and `\` with numbes for octal (e.g. `\24`)
    - Using spaces between string literals will concatenate them
        ```cpp
        "this" "is a"
        "single string"
        // Same as
        "thisis asingle string"
        ```
    - Using `\` in a string means line continuation which means line continues where it stopped
        ```cpp
        x = "string in \
        two lines"
        // Same as
        x = "string in two lines"
        ```
        - DONE: Does this work with indents?
            Indents count
        ```cpp
        int main() {
            x = "string in \
            two lines"
            // Same as
            x = "string in      two lines"
        }
        ```
    - By default, characters in string literal have type `char`. To modify, use:
        - u for char16_t
        - U for char32_t (note case sensitivity)
        - L for wchar_t
        - Attempted to use in example but getting conversion error =/
            ```
            main.cpp:8:26: error: conversion from ‘const char16_t [13]’ to non-scalar type ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’ requested
               std::string mystring = u"Hello World!";
            ```
    - Also have:
        - u8 for UTF-8 encoding (guess default is ASCII)
        - R is raw string (meaning all characters are taken as is, no escaping)
            - Usage: R"{sequence}contents{sequence}"
            ```cpp
            R"(string with \backslash)"
            R"&%$(string with \backslash)&%$"
            // Both equivalent to
            "string with a \\backslash"
- More literals:
    - Boolean: true/false
    - `nullptr` is null pointer value (unsure what that means, guessing 0?)
    ```cpp
    bool foo = true;
    bool bar = false;
    int* p = nullptr;
    ```

Head is feeling kind of full, stopping at "typed constant expressions" on https://www.cplusplus.com/doc/tutorial/constants/

Attempted to look ahead for header explainer, shocked to not see any
Reading this instead: https://www.cplusplus.com/articles/Gw6AC542/

- Multiple files speeds up compile time
    - I guess compiler caches results for each of the files?
- Multiple files is for organization, yep
- ... Alright, this file is going to get into the weeds and head is still full. Going to come back another time

... and back

- Multiple files allows for separating interface from implementation
    - So I guess overriding and such?

C++ built in 2 stages:
- Each file is compiled on its own into intermediate files, called object files (unrelated to objects in code)
- Then each file is linked together to final binary (program itself)

- Example code showing `.cpp` files aren't shared
    ```cpp
    // myclass.cpp
    class MyClass {
        // ...
    }
    ```
    ```cpp
    // main.cpp
    MyClass a; // Compile error: 'MyClass' is unidentified
    ```
- i.e. When we compile each `.cpp` file on its own, it doesn't have anything linking the files so they error out
    - Ohhh, gotcha

- Here's where header files come in (yay)
    - They define the interface (i.e. what MyClass receives and such) while leaving the implementation separate (in its own `.cpp` file)
    - I feel like it's not a great trade-off but alright
        - Could prob just as easily scrape the `.cpp` file for that info or something
        - Maybe it was a product of the times when processors and disk storage were a lot slower
- Updated example:
    ```cpp
    // myclass.h
    class MyClass
    {
    public:
        void foo();
    }

    // myclass.cpp
    #include "myclass.h"

    void MyClass::foo()
    {
        // Guessing this overrides `foo` placeholder
        // Curious how C++ distinguishes the files
    }

    // main.cpp
    #include "myclass.h"

    MyClass a; // No more error
    ```
- `#include` will copy/paste all of the `.h` into the file
    - I guess dead code will be abstracted away

## Distinction between .h/.cpp/.hpp/.cc/etc
- Fundamentally all text files but there's conventions

- Header files should use `.h/.hpp/.hxx`
- C++ source files should use `.cpp/.cxx/.cc`
- C source files should only use `.c`

We separate C++ from C as it affects some compilers
Since on a C++ site, prob only writing C++ so avoid the `.c` extension

Also, compilers might try to avoid header extensions

To reiterate from before:
- Header files are loaded via `#include` and not compiled
- Source files are not loaded via `#include` and are compiled

There are rare exceptions to the rule, your scenario prob doesn't count (only one listed is about templates which already sounds sketchy)
so yea... don't

## Include guards
- C++ compilers will complain if include is used twice
    ```cpp
    # include "myclass.h"
    # include "myclass.h" // Compiler error - MyClass already defined
    ```

- This can be frustrating if we include a file twice in multiple dependencies
    e.g. `a.h` imports `x.h`, `b.h` imports `x.h`, and `main.cpp` imports `a.h` and `b.h`
- Because of this, people are often told to avoid `#include` in header files which is bad advice
    - Sometimes instructed to do so, you can grudgingly do it but shake it once leaving the class
- Can do `#include` in header files but take precautions:
    - Only include what is needed
    - Guard against multiple includes:
        - Example:
        ```cpp
        // x.h
        #ifndef __X_H_INCLUDED__ // if x.h hasn't been included yet (if not defined)
        #define __X_H_INCLUDED__ //   #define this so the compiled knows it has been included

        class X { };
        #endif
        ```
        - Note: Because this logic is going in `x.h`, then it will always work -- nothing to put inside of `a.h` or `b.h`
        - I'm a little curious if we get global namespace pollution issues but I guess that comes later
        - Obviously no need to guard `.cpp` files like this since they aren't loaded via `#include`
        - DONE: I'm curious what built-ins do, do they do a similar setup?
            Oooh, they do =o
            > Via /usr/include/c++/7/string
            ```cpp
            #ifndef _GLIBCXX_STRING
            #define _GLIBCXX_STRING 1
            ```
            > Comical that `<string>` now mostly uses `<bits/*>` libraries

## Right way to include
Two kind of dependencies:
- Forward declared
- `#include`

Example: Class A uses Class B (thus A depends on B)

If A makes no reference to B, then do nothing
If A only refers to B in friend declaration, then do nothing

If A containers a B pointer or reference (e.g. B* myb), then use forward declaration
If one or more functions has a B obj/ptr/ref/etc, then use forward declaration

If B is a parent class of A, then use `#include`
If A contains a B object, then use `#include`

Full example:
```
// include guard
#ifndef __MYCLASS_H_INCLUDED__
#define __MYCLASS_H_INCLUDED__

// Forward declared dependencies
class Foo;
class Bar;

// included dependencies
#include <vector>
#include "parent.h"

// class itself
class MyClass : public Parent # Use as `Parent` so `#include "parent.h"`
{
public:
    std::vector<int> avector; // Uses vector as an object to `#include <vector>`
    Foo* foo; // Foo pointer, so forward declare Foo (I guess this is when we define the name of it only and allow others to fill in the rest?)
    void Func(Bar& bar); // Bar reference, so forward declare Bar

    friend class MyFriend; // friend declaration, not a dependency so nothing needed
}

#endif // __MYCLASS_H_INCLUDED__ (end of guard)
```

- Avoid unnecessary `#include` as it can lead to trouble

## Why was that the "right way"?
- Careless usage of `#include` can lead to trouble
    - One way to avoid it is abstinence but that leads to lots of work and headaches
- This methodology focuses on encapsulation and no other file needs to know internals of `.h` file
    - Alternative would mean loading all of `.h` dependencies in program, including its nested ones which is a paiiin

## Circular dependencies
> Usually this means misstructuring of code in my experience =/
> A parent with 2 children dependency or 2 parents with 1 child instead of 2 siblings with more code somewhere

But they say...
If we only need a forward declaration at some point, then circle is broken and it works

```cpp
// a.h
#include "b.h"

class A { B* b; };

// b.h
#include "a.h"

class B { A* a; };
// Still getting used to `;` on braces
```

This will result in infinite inclusion loop =/
but due to guarding, we stop recursing an error out

```cpp
#include "a.h"
    #include "b.h"
        #include "a.h"
            // Hit guard

    class B { A* a;} // Error: A is undeclared
```

"This is why always forward declare when using pointer or reference"
So we should be avoiding the circular `#include` altogether

If we use an object though (e.g. `B b;`, not `B* b;`), then need to do `#include`

... Impossible so just use a pointer or reference rather than full object
> Or y'know, break up the code...

## Function inlining
Function body needs to exist in every `.cpp` file which calls them, otherwise there are linker errors
> I'm a little curious how compiler knows which `.cpp` files to load and when but maybe that's just what's passed in or it sees the `.h` files

```cpp
class B
{
public:
    void Func(const A& a) // parameter so fwd declare is okay
    {
        a.DoSomething(); // a is dereferenced now so need an `include`, thus we have circular inclusion
    }
};
```

While inline function needs to exist in header, doesn't need to be in class definition, so can exploit via:

```
// b.h
class A; // fwd declared dependency

class B
{
public:
    void Func(const A& a); // Fwd declared A used, good
};

// Load a.h properly via `include`
#include "a.h"

inline void B::Func(const A& a)
{
    a.DoSomething(); // Works dude to `include
}
```

Wow, that's one clever hack. It breaks the circular dependency since it makes progress

- Function bodies at bottom header is ugly though, can we avoid it?
    - Yes, move bodies to another header (e.g. `b_inline.h`)
    - Hahaha, I guess that works

## Forward declaring templates
This is getting into a world which I'm very unfamiliar with and my eyes have glazed over

Going to call it as good enough for now and we can always come back

Calling it for the night here

# 2020-08-18
Resuming at "typed constant expressions" on https://www.cplusplus.com/doc/tutorial/constants/

- Using `const` before type declaration seems to make it a constant variable...
    ```cpp
    const double pi = 3.14159;
    const char tab = '\t';
    ```
- Curious what happens when we try to update it, they don't cover this but yea...
    - `05-const`, yep confirms expected
        ```
        main.cpp: In function ‘int main()’:
        main.cpp:14:8: error: assignment of read-only variable ‘pi’
           pi = 3.14;
                ^~~~
        ```

- Can also use `#define` via preprocessor which I believe does something different
    ```cpp
    # define PI 3.14159
    // ...
    cout << PI;
    ```
    - This behaves a replacement so overriding makes less sense
    - Unless... what happens when we override a `#DEFINE`?
        - Exploring in `06-define`
            - It outputs a warning
            ```
            main.cpp:6:0: warning: "PI" redefined
             #define PI 3

            main.cpp:5:0: note: this is the location of the previous definition
             #define PI 3.14159

            3
            ```
    - `#define` don't require semicolons since preprocessor directives
        - (and semicolon would be considered part of the line)
