# 2020-07-21
# Informational links
- https://www.cplusplus.com/info/description/
    - Good overview of language types, nothing new for me =/
- https://www.cplusplus.com/info/history/
    - Skimmed, nice history on C++
- https://www.cplusplus.com/info/faq/
    - Good clarifications on a few things
    - Including that ANSI-C++ is a standard, whereas iirc there's inconsistencies between compilers so we have to wrangle with defined vs undefined behavior

# Tutorial
# https://www.cplusplus.com/doc/tutorial/introduction/

Assembly...

How compilation works...

Console programs...

Due to being on Linux, we'll use `g++`
Clang is good for OS X

# https://www.cplusplus.com/doc/tutorial/program_structure/
- Code comments
- `#` is a directive symbol
    - `#include` means to insert the code into this file (kind of like PHP `include`)
        - As opposed to Python and Node.js `import`/`require` which load that part of the program as a module which can be referenced but isn't in the same file per-se
    - `#include <iostream>` means include the *header* for iostream (still need to fully understand what a header is...)
- `int main ()` - Declare a function which returns an `int`, is called `main`, and takes 0 parameters
    - `main` is special as it's what's called when the program is run
    - Not mentioned: `int` is going to be the exit code of the program
        - If not specified, then the function will return `0` by default (success exit code)
- `std::cout` - `std` is standard, `cout` is character output
- `<<` is insertion operator so we insert the string to `std::cout`

- Multiple `std::cout` calls continues outputting

## Comments
- `//` is single line ocmment
- `/* */` is multiline comment

## Namespaces
- In some other code, might have seen no `std::` used
    - This is due to using the `std` namespace by default (see below)
    - However, `std::cout` and `cout` refer to the same object
        - `cout` is called unqualified
        - `std::out` is called qualified, with the namespace `std`
- `cout` is part of standard C++ library, declared within the `std` namespace
    - To refer to items within `std` namespace, program shally qualify usage of elements of library (e.g. `std::`) or "introduce visibility of its components"
        - Visibility is done most often with `using` delcaration
        - e.g. `using namespace std;`

Future code examples will use similar `using` syntax

Both are valid but only using non-`using` syntax is good to avoid name collisions (seems backwards reinforcement...)

For personal reference, here's the error when we try `cout` without `std::` and no `using namespace`:

```
main.cpp: In function ‘int main()’:
main.cpp:7:3: error: ‘cout’ was not declared in this scope
   cout << "Hello World!\n";
   ^~~~
main.cpp:7:3: note: suggested alternative:
In file included from main.cpp:2:0:
/usr/include/c++/7/iostream:61:18: note:   ‘std::cout’
   extern ostream cout;  /// Linked to standard output
```

Oooh, really cool insight that C++ std lib are just a file locally

```
less /usr/include/c++/7/iostream
```

# https://www.cplusplus.com/doc/tutorial/variables/
- Variables...

- Addition, subtraction, and equals operators (implicit)


## Identifiers
- Valid identifer is a sequence of at least 1 letter, digit, or underscore (no spaces, punctuation, or symbol allows)
    - Also always starts with a letter or underscore (usually only for compiler-specific keywords, external identifiers, or __ variants)

Here's an example error:

```
main.cpp: In function ‘int main()’:
main.cpp:9:7: error: expected unqualified-id before numeric constant
   int 1foo = 3;
       ^~~~
```

- Cannot use reserved keywords, giant list...
    ```
    alignas, alignof, and, and_eq, asm, auto, bitand, bitor, bool, break, case, catch, char, char16_t, char32_t, class, compl, const, constexpr, const_cast, continue, decltype, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, new, noexcept, not, not_eq, nullptr, operator, or, or_eq, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_assert, static_cast, struct, switch, template, this, thread_local, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while, xor, xor_eq
    ```
    - Some compilers might have more

- C++ is case-sensitive so RESULT !== result !== Result

## Fundamental data types
- Variable values are stored in memory at an unspecified location as 0s and 1s, don't need to know per-se
- We do need to know type though as interpretation and memory usage varies widely

- We've got the following types:

- Character types, representing text (e.g. 'A', '$')
    - `char`, a single character - One byte in size (at least 8 bits)
    - `char16_t`, "Not smaller than `char`" (at least 16 bits)
    - `char32_t`, "Not smaller than `char32_t`" (at least 32 bits)
    - `wchar_t` - *Can* reprepsent largest supported character set
        > It's annoying how these are all not rigid ("not smaller than", "can")
        > Really want it to be 16-bit character, 32-bit character, "is" not "can
        > Ugh...
- Numerical integer types (e.g. 7. 1024)
    > `signed`, not well explained but allows for +/- values down to half of range and up to half of range (e.g. 8 bits -> -128 to 127)
    > `unsigned`, full range from 0 to value (e.g. 8 bits -> 0 to 255)
    - `char`, at least 8 bits
    - `short`, at least 16 bits (at least `char`)
    - `int`, at least 16 bits (at least `short`)
    - `long int`, at least 32 bits (at least `int`)
    - `long long int`, at least 64 bits (at least `long`)
- Numerical floating-point types (e.g. 3.14, 0.01)
    > Broken down into significand/mantissa bits and exponent bits, kind of like 3.14e+14
    - `float`, no mention of bits
    - `double`, precision not less than `float`
    - `long double`, precision not less than `double`
- Boolean type (e.g. `true`, false`)
    - `bool`, 1 bit
- Void type
    - `void`, 0 bits (no storage)
- Null pointer
    - `decltype(nullptr)` (no info)
    > I'm guessing pointers are their own type which get size assigned by the OS?

Words `signed` and `int` can be omitted (except for in `char` case)
e.g. `signed short int` can be `signed short`, `short int`, or `short`

**None of the fundamental types have a standard size specified except `char`, only a minimum size at most**
This is due to different compilers and machines doing different things

"This allows for flexibility to work optimally in all kinds of platforms, both present and future"
> Hahaha... good joke there... so much broken code... so much -_-;;;

8-bit = 2^8 = 256 represnetable values
16-bit = 65,536
32-bit = 4,294,967,296 (~4 billion)
64-bit = 18,446,744,073,709,551,616 (~18 billion billion)

Clarification on signed vs unsigned: 655356 -> 0 to 65535 (unsigned), -32768 to 32767 (signed)
Yep, so I was right =D

Clarification on floating points, terms are called significant and exponent (mostly right before)

Limitations of a given system can be resolved via `numeric_limits` classes inside of `limits` header

> My eyes are glazing over when I see this... `template <class T>` keeps on throwing me/scaring me off =/
> https://www.cplusplus.com/reference/limits/numeric_limits/
> Ah, usage is like `std::numeric_limits<int>::min()`
> Staaarting to click a little

Paused at "If for some reason, types of specific sizes are needed, the library defines certain fixed-size type aliases in header <cstdint>."

# 2020-07-28
Aaaand we're back

https://www.cplusplus.com/reference/limits/numeric_limits/

```cpp
template <class T> class numeric_limits {
public:
  static T min() throw();
};

// Translates to usage:
//                   v static public method
numeric_limits<int>::min();
// ^ class,    ^ template class
```

https://www.cplusplus.com/doc/tutorial/variables/

Resuming tutorial now...

- Types (characters, integers, floating-point, and boolean) are known as arithmetic types
    - Huh, would have expected "primitive"
- `void` means it lacks a type
- `nullptr` is a special kind of pointer, not an arithmetic type
- Other types are known as compound data types

## Declaration of variables
- C++ strongly typed... requires declaration before use...
    - Useful for compiler...

```cpp
int a;
float mynumber;
```

- Scope of these declarations are allowed in the entirety of the rest of the program
- Can use commas for combined declaration (my experience in JS has taught me split line is better since usually declaration and initialization should go hand-in-hand)
    - `int a, b, c;`


- Code example: 02-variable-declaration

## Initialization of variables
- When variables declared but not set, their value is undetermined
    > What happens if we try to work with an undetermined value?
    > It seems to default to `0` usually but when we subtract, we're getting an underflow and varying between 32764 and 32767
    ```cpp
    // Process our variables
    // a = 5;
    // b = 2;
    // a += 1;
    result = a - b;
    ```
- Setting variable is called initalization
- 3 ways to initialize, whoa!
    - All valid and come from language evolution
    - C-like initialization
        - `type identifier = initial_value;`
        - e.g. `int x = 0;`
    - Constructor initialization (not part of C)
        - `type identifier (initial_value);`
        - e.g. `int x (0);`
    - Uniform initialization, similar to constructor variant, introduced in 2011:
        - `type identifier {initial_value};`
        - e.g. `int x {0};`
> These latter 2 seem strange, I bet they're more applicable to classes (I think C already had structs though so curious...)

- Code example: 03-variable-initialization

# Type deduction
- Compiler can automatically deduce type based on previous declarations
    - I've heard frustrating stories of libraries being inundated with `auto` and causing headaches =/
    ```cpp
    int foo = 0;
    auto bar = foo; // Uses `int bar`, based on `foo`
    ```
- If a variable only declared, not initialized, then they can use `decltype` for same effect:
    ```cpp
    int foo = 0;
    decltype(foo) bar;
    ```

- Warnings about intended for inability of not knowing type (e.g. library) or if it improves code readability, examples above decreased readability

## Introduction to strings
- Strings are a compound type, loaded via the `<string>` header
    ```cpp
    #include <string>
    // ...
    string mystring = "This is a string";
    ```
- Use same 3 initialization calls for demo purposes
- `endl` will print newline character (guessing this varies based on OS, e.g. Windows is `\r\n`, Linux is `\n` only)

- Lots of different constructor methods, https://www.cplusplus.com/reference/string/string/string/
    - Pretty sure we're just starting with the "from c-string" variant

- Code example 04-strings

- So many error messages when we forego `using namespace std;` o_o

```
main.cpp: In function ‘int main()’:
main.cpp:8:3: error: ‘string’ was not declared in this scope
   string mystring = "Hello World!";
   ^~~~~~
main.cpp:8:3: note: suggested alternatives:
In file included from /usr/include/c++/7/iosfwd:39:0,
                 from /usr/include/c++/7/ios:38,
                 from /usr/include/c++/7/ostream:38,
                 from /usr/include/c++/7/iostream:39,
                 from main.cpp:2:
/usr/include/c++/7/bits/stringfwd.h:74:33: note:   ‘std::__cxx11::string’
   typedef basic_string<char>    string;
                                 ^~~~~~
/usr/include/c++/7/bits/stringfwd.h:74:33: note:   ‘std::__cxx11::string’
main.cpp:11:16: error: ‘mystring’ was not declared in this scope
   std::cout << mystring << endl;
                ^~~~~~~~
main.cpp:11:16: note: suggested alternative: ‘stdin’
   std::cout << mystring << endl;
                ^~~~~~~~
                stdin
main.cpp:11:28: error: ‘endl’ was not declared in this scope
   std::cout << mystring << endl;
                            ^~~~
main.cpp:11:28: note: suggested alternative:
In file included from /usr/include/c++/7/iostream:39:0,
                 from main.cpp:2:
/usr/include/c++/7/ostream:590:5: note:   ‘std::endl’
     endl(basic_ostream<_CharT, _Traits>& __os)
     ^~~~
```

## Constants
## Literals
- Integer literals (e.g. 100, -200)
    - No quotes, representing base 10 by default
    - Octal, leading `0`: `0113`
    - Hexadecimal, leading `0x`: `0x4b`
    - Default is type `int`, for variation, use following:
        - u or U for unsigned: 75u
        - l or L for long: 75l
        - ll or LL for long long: 75ll
        - Demo: 75ul, unsigned long
- Floats, similar base 10 literals: (e.g. 3.14)
    - Supports exponent form (e.g. 6.02e23, 1.6e-19)
    - Modify with:
        - f or F for float: 6.02e23f
        - l or L for long double: 3.14159L
- String literals
    - Single character, use single quotes (e.g. 'z', 'p')
    - Strings (more than 1 char), use double quotes (e.g. "Hello world")
    - Special characters use `\` to escape (e.g. \n, \r, \', \\)
    - Can also use `\x` for hex version (e.g. `\x20`) and `\` with numbes for octal (e.g. `\24`)
    - Using spaces between string literals will concatenate them
        ```cpp
        "this" "is a"
        "single string"
        // Same as
        "thisis asingle string"
        ```
    - Using `\` in a string means line continuation which means line continues where it stopped
        ```cpp
        x = "string in \
        two lines"
        // Same as
        x = "string in two lines"
        ```
        - DONE: Does this work with indents?
            Indents count
        ```cpp
        int main() {
            x = "string in \
            two lines"
            // Same as
            x = "string in      two lines"
        }
        ```
    - By default, characters in string literal have type `char`. To modify, use:
        - u for char16_t
        - U for char32_t (note case sensitivity)
        - L for wchar_t
        - Attempted to use in example but getting conversion error =/
            ```
            main.cpp:8:26: error: conversion from ‘const char16_t [13]’ to non-scalar type ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’ requested
               std::string mystring = u"Hello World!";
            ```
    - Also have:
        - u8 for UTF-8 encoding (guess default is ASCII)
        - R is raw string (meaning all characters are taken as is, no escaping)
            - Usage: R"{sequence}contents{sequence}"
            ```cpp
            R"(string with \backslash)"
            R"&%$(string with \backslash)&%$"
            // Both equivalent to
            "string with a \\backslash"
- More literals:
    - Boolean: true/false
    - `nullptr` is null pointer value (unsure what that means, guessing 0?)
    ```cpp
    bool foo = true;
    bool bar = false;
    int* p = nullptr;
    ```

Head is feeling kind of full, stopping at "typed constant expressions" on https://www.cplusplus.com/doc/tutorial/constants/

Attempted to look ahead for header explainer, shocked to not see any
Reading this instead: https://www.cplusplus.com/articles/Gw6AC542/

- Multiple files speeds up compile time
    - I guess compiler caches results for each of the files?
- Multiple files is for organization, yep
- ... Alright, this file is going to get into the weeds and head is still full. Going to come back another time
